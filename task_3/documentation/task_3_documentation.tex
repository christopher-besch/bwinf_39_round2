\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% todo: check TeilnahmeId
\newcommand{\Aufgabe}{Aufgabe 3: Eisbudendilemma}
\newcommand{\TeilnahmeId}{56860}
\newcommand{\Name}{Christopher Besch}


% header and footer
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Teilnahme-ID: \TeilnahmeId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% title position
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% for math commands and symbols
\usepackage{amsmath}
\usepackage{amssymb}

% for images
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{subcaption}

% for tables
\usepackage{tabularx}

% for algorithms
\usepackage{algpseudocode}

% for indented block
\usepackage{scrextend}

% for source code
\usepackage{listings}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  keywordstyle=\color{blue},commentstyle=\color{mygreen},
  stringstyle=\color{mymauve},rulecolor=\color{black},
  basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
  captionpos=b, % sets the caption-position to bottom
  keepspaces=true, % keeps spaces in text
  numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
  showtabs=false, stepnumber=2, tabsize=2, title=\lstname
}
\lstdefinelanguage{JavaScript}{ % JavaScript is the only non-predefined language
  keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  sensitive=true
}

% these packages must be loaded last
\usepackage{hyperref}
\usepackage{cleveref}

% c++ source code setup
\lstset{
    language=C++,
    basicstyle=\small\sffamily,
    numbers=left,
    numberstyle=\tiny,
    frame=tb,
    tabsize=4,
    columns=fixed,
    showstringspaces=false,
    showtabs=false,
    keepspaces,
    commentstyle=\color{red},
    keywordstyle=\color{blue}
}

\newcommand{\imageWidth}{0.3\linewidth}

% title
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Teilnahme-ID: \LARGE \TeilnahmeId \\\\
	    \LARGE Bearbeiter/-in dieser Aufgabe: \\ 
	    \LARGE \Name\\\\}
\date{\LARGE\today}

\begin{document}

\maketitle
\tableofcontents

\vspace{0.5cm}

\section{Ein Wort über die Graphiken}
Alle in dieser Dokumentation verwendeten Darstellungen verwenden einheitliche Symbole:
\begin{itemize}
    \item Der See ist als schwarzer Kreis dargestellt.
    \item Die Häuser sind verschieden gefärbte Rechtecke, deren Adresse außerhalb des Kreises stehen:
          \begin{itemize}
              \item Rot: Das Haus stimmt gegen eine Verlegung der Eisdielen.
              \item Grün: Es stimmt für eine Verlegung.
              \item Andere Farben werden verwendet, um bestimmte Häuser herauszuheben.
                    Die jeweiligen Bedeutungen werden darstellungsspezifisch angegeben.
          \end{itemize}
    \item Die Adressen sind aufsteigend im Uhrzeigersinn angeordnet.
          Adresse $0$, die Dorfkirche befindet sich oben.
    \item Blaue Kreuze stellen die Positionen des Test-Arrangements dar und
    \item blaue Kreise die des Check-Arrangements.
          In beiden Fällen stehen die Adressen innerhalb des Kreises.
\end{itemize}

\section{Lösungsidee}
% Die Idee der Lösung sollte hieraus vollkommen ersichtlich werden, ohne dass auf die eigentliche Implementierung Bezug genommen wird.
Das Ziel ist es, ein Arrangement bestehend aus drei Positionen für Eisdielen zu generieren, das in einer Abstimmung durch kein anderes Arrangement abgelöst werden kann.
Diese Arrangements werden stabil genannt.
Hierzu darf die Eisdielendistanz, die Strecke zwischen einem beliebigen Haus und der nächsten Eisdiele, von nicht mehr als der Hälfte der Hauser durch ein anderes Arrangement verkürzt werden.
Wäre dies der Fall, würde die Ablösung mehr Ja- als Nein-Stimmen erhalten.
Hieraus geht hervor, dass für eine optimale Lösung alle möglichen Arrangements (Diese werden Test-Arrangement genannt.) auf Stabilität überprüft werden müssen.
Um die Stabilität zu bestimmen, muss das Test-Arrangement mit allen möglichen anderen Arrangements (Check-Arrangement genannt) verglichen werden.
Wenn auch nur ein einziges Check-Arrangement gefunden wird, das mehr Ja- als Nein-Stimmen erhält, ist das getestete Test-Arrangement instabil.
Es lässt sich leicht erkennen, dass dieser Algorithmus, der Durchgang aller möglichen Test-Arrangements, mit einer Laufzeit von $O(n^6)$ nicht verwendbar ist.

\subsection{Sortierung der Arrangements}
\label{sec:Sortierung_der_Arrangements}
Als Versuch der Optimierung werden bevor sie getestet werden alle Arrangement sortiert.
Hierzu wird für jedes mögliche Arrangement ein Score berechnet.
Dieser entspricht der durchschnittlichen Eisdielendistanz aller Häuser.
Nun stellt sich heraus, dass stabile Arrangements einen der niedrigsten Scores aller Arrangements aufweisen.
Dies lässt sich damit erklären, dass je kleiner die Eisdielendistanz eines Hauses in einem Test-Arrangement ist, desto weniger Check-Arrangement existieren, die eine noch geringere Eisdielendistanz für das Haus generieren.
Wenn die Eisdielendistanz beispielsweise $0$ beträgt, existiert kein einziges Check-Arrangement, dem dieses Haus eine Ja-Stimme geben würde, da eine geringere Eisdielendistanz nicht möglich ist und ein Haus bei gleichbleibender Eisdielendistanz immer gegen einen Wechsel stimmt.
Dies ist in \autoref{fig:01_hapy_house} gezeigt.
\begin{figure}[ht]
    \centering
    \caption{Das einzige Haus ist zufrieden mit der einzigen Eisdiele und lehnt jegliche Veränderung ab. Die Eisdielendistanz beträgt $0$.}
    \label{fig:01_hapy_house}
    \includegraphics[width=\imageWidth]{01_happy_house.png}
\end{figure}
Wenn die Eisdielendistanz den maximalen Wert, dem halben Umfang des Sees, entspricht, stimmt es für alle Check-Arrangements (\autoref{fig:02_unhappy_house}), abgesehen von denen, die die Eisdielendistanz nicht verändern (\autoref{fig:03_slightly_happy_house}).
\begin{figure}[ht]
    \centering
    \caption{Unzufriedene Häuser}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{02_unhappy_house.png}
        \caption{Das Haus ist maximal unzufrieden, weshalb es für fast jede Verlegung stimmt. Jeder Kreis repräsentiert eine anderes Check-Arrangement, die alle von dem Haus angenommen werden.}
        \label{fig:02_unhappy_house}
    \end{subfigure}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{03_slightly_happy_house.png}
        \caption{Dies ist der einzige Fall, in dem das Haus trotz seiner extremen Unzufriedenheit gegen eine Verlegung stimmt.}
        \label{fig:03_slightly_happy_house}
    \end{subfigure}
\end{figure}
Die durchschnittliche Eisdielendistanz lässt sich dementsprechend als \glqq Zufriedenheitsgrad\grqq{} des Dorfes interpretieren.
Je höher er ist, desto unwahrscheinlicher wird eine Verlegung durchgesetzt.

Allerdings muss dieser Wert nicht zwangsweise mit der Stabilität eines Arrangements übereinstimmen, was beispielsweise in \autoref{fig:04_broken_example} gezeigt wird.
\begin{figure}[ht]
    \centering
    \caption{Trotz der für dieses Beispiel, \textit{eisbuden3.txt}, minimalen durchschnittlichen Eisdielendistanz von $3,3125$ stimmen mehr Häuser für eine Verlegung.}
    \label{fig:04_broken_example}
    \includegraphics[width=\imageWidth]{04_broken_example.png}
\end{figure}
Hieraus geht hervor, dass die durchschnittliche Eisdielendistanz nur eine Näherungslösung liefert.
Trotzdem kann sie zur Generierung eines Satzes an Test-Arrangements verwendet werden, die anschließend von dem bereits genannten Algorithmus auf Stabilität überprüft werden.

\subsection{Bestimmung der Stabilität}
\label{sec:Bestimmung_der_Stabilität}
Um die Stabilität eines Test-Arrangements zu berechnen, müssen alle möglichen Check-Arrangements durchgegangen werden.
Es wird nur eine einziges Check-Arrangement gesucht, das das Test-Arrangement schlagen kann.
Daher können zwei Optimierungen getroffen werden:
\begin{enumerate}
    \item Eisdielen sollten nicht übereinander liegen, da bei der Aufsplittung zweier aufeinanderliegender Eisdielen die Eisdielendistanz keines Häuses vergrößert wird.
    \item Alle Dopplungen sind unnötig, da die Reihenfolge der Eisdielen für die Stimmen der Häuser irrelevant sind.
\end{enumerate}
Deshalb darf die Bedingung gelten, dass die Adresse der zweiten Eisdiele größer als die der ersten und kleiner als die der dritten ist.
Hieraus folgt, dass der See in drei Sektoren unterteilt ist (\autoref{fig:05_sectors}).
\begin{figure}[ht]
    \centering
    \caption{Einteilung in Sektoren}
    \label{fig:05_sectors}
    \includegraphics[width=\imageWidth]{05_sectors.png}
\end{figure}

\subsubsection{Auszählung der Stimmen}
\label{sec:Auszählung_der_Stimmen}
Es zeigt sich, dass die Stimme der Häuser innerhalb eines Sektors ausschließlich durch die Größe und Position des Sektors und die in dem Sektor befindlichen Eisdielen des Test-Arrangements determiniert sind.
\begin{itemize}
    \item Alle Test-Eisdielen außerhalb des Sektors sind von den Häusern immer weiter entfernt als die Ränder des Sektors, weshalb sich die ehemalige Eisdielendistanz ohne Test-Eisdielen innerhalb des Sektors nie verkürzen wird.
    \item Genauso ist für jedes Haus im Sektor eine der Sektorgrenzen immer die nächste Check-Eisdiele.
          Dementsprechend ist die Position der dritten Check-Eisdiele ebenfalls irrelevant. da immer nur die Eisdielendistanz betrachtet wird.
\end{itemize}
Aus diesen beiden Punkten geht hervor, dass ausschließlich die Ränder des Sektors und die sich im Sektor befindlichen Test-Eisdielen Einfluss auf die Stimme eines Hauses in dem Sektor hat.

\medskip
Nun wird sich die Verteilung der Ja- und Nein-Stimmen betrachtet.
In einem Sektor können sich keine (\autoref{fig:06_no_test_ice}) nur eine (\autoref{fig:07_one_test_ice}) oder mehr Eisdielen (\autoref{fig:08_two_test_ice}) befinden.
\begin{figure}[ht]
    \centering
    \caption{Test-Eisdielen Anordnung im Sektor}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{06_no_test_ice.png}
        \caption{Keine Test-Eisdiele}
        \label{fig:06_no_test_ice}
    \end{subfigure}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{07_one_test_ice.png}
        \caption{Eine Test-Eisdiele}
        \label{fig:07_one_test_ice}
    \end{subfigure}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{08_two_test_ice.png}
        \caption{Zwei oder mehr Test-Eisdielen (nur die Äußersten dargestellt)}
        \label{fig:08_two_test_ice}
    \end{subfigure}
\end{figure}

In dem letzten Fall von mehr als zwei Test-Eisdielen im Sektor, müssen nur die Äußersten betrachtet werden, da zwischen diesen beiden keine Check-Eisdiele stehen kann.
Dies geht aus der Definition eines Sektors hervor.
Somit stimmen immer alle Häuser zwischen diesen gegen eine Verlegung, unabhängig von der Menge and Test-Eisdielen.

Um die Anzahl an Nein- beziehungsweise Ja-stimmenden Häusern zu bestimmen wird müssen zwei verschiedene Methoden verwendet werden:
\begin{itemize}
    \item Wenn sich keine Test-Eisdiele in dem Sektor befindet, stimmt kein Haus gegen eine Verlegung.
    \item In allen anderen Fällen befinden sich die einzigen Ja-stimmenden Häuser in den beiden Bereichen zwischen einem Rand un der nächsten Test-Eisdiele.
          Wenn diese Bereiche in der Mitte geteilt wird, befinden sich alle Ja-stimmenden Häuser in der Hälfte, die näher am Rand ist.
          Alle Nein-stimmenden Häuser liegen in der anderen Hälfte.
          Bei einer ungeraden Anzahl an Adressen in diesem Bereich wird der Nein-stimmenden Hälfte eine Adresse mehr zugeteilt, da bei gleichbleibender Eisdielendistanz das Haus Nein stimmen.
\end{itemize}
Auf diese Weise können effizient die Bereiche berechnet werden, in denen alle sich befindlichen Häuser Nein stimmen.

\medskip
Es ergibt sich ein weiterer Vorteil:
Um alle Position für die Check-Eisdielen durchzugehen, können zuerst zwei Positionen für die ersten beiden Eisdielen festgesetzt werden und daraufhin alle möglichen Positionen für die dritte Eisdiele verwendet werden, die die genannten Bedingungen erfüllt.
Die verschiedenen Optionen für die ersten beiden Check-Eisdielen müssen in einem übergeordneten Schritt durchgegangen werden.
Somit ist die Größe und Position des ersten Sektors bei vielen Durchläufen gleich.
Wenn bereits mindestenz die Hälfte der Häuser sich in diesem Sektor befinden und gegen eine Veränderung stimmen, ist das Check-Arrangement unfähig, das Test-Arrangement abzulösen.
Somit kann in diesem Fall die Suche nach Positionen für die dritte Check-Eisdiele übersprungen werden und die Wahl der ersten beiden Check-Eisdielen sofort geändert werden.

\section{Umsetzung}
% Hier wird kurz erläutert, wie die Lösungsidee im Programm tatsächlich umgesetzt wurde. Hier können auch Implementierungsdetails erwähnt werden.
Die Lösungsidee wird in C++ implementiert.
Der Übersichtlichkeit halber ist das Programm in drei Dateien unterteilt:
\begin{itemize}
    \item \textbf{main.cpp} liest die Eingabe und gibt die Ergebnisse aus,
    \item \textbf{utils.h} enthält verwendete Structs und generell anwendbare Funktionen und Makros und
    \item \textbf{calculate\_stable.h} enthält die eigentlichen Funktionen zur Bestimmung der stabilen Arrangements.
\end{itemize}
Die einzigen Eingaben, die das Programm benötigt ist der Pfad der Eingabedatei und die optionale Angabe der Menge an besten Arrangements, die auf Stabilität überprüft werden sollen.
Je geringer dieser Wert ist, desto kürzer ist die Laufzeit.
Allerdings ist ein zu niedriger Wert problemtisch, da wie bereits in \autoref{fig:04_broken_example} gezeigt, die stabilen Arrangements nicht zwingendermaßen die geringste Eisdielendistanz aufweisen.
Wenn kein Wert angegeben wird, werde die $600$ besten Arrangements überprüft.
Dieser Wert ist eine gute Wahl für die Beispieldateien.

\subsection{Einlese der Eingabedatei}
\label{sec:Einlese_der_Eingabedatei}
Als erster Schritt wird in der Funktion \textbf{read\_file} die Eingabedatei gelesen.
Hierbei wird überprüft, ob die Eingabedatei dem gegebenen Format entspricht, wenn nicht wird das Programm abgebrochen.
Hierzu wird ein Makro \textbf{raise\_error()} verwendet, das die Ausführung des Programms abbricht und eine möglichst informative Fehlermeldung zurückgibt.

Schlussendlich wird eine Instanz des \textbf{Lake} Structs erstellt.
Dieses enthält:
\begin{itemize}
    \item den Umfang des Sees,
    \item ein std::vector aller Häuser (repräsentiert durch \textbf{House} Instanzen, die jeweils die Adresse und Platz für die jeweilig notwendige Eisdielendistanz enthält),
    \item eine Karte des Sees, ein std::vector mit einem uint8\_t pro Adresse.
          Wenn ein Haus bei dieser Adresse existiert, ist das entsprechende Element $1$, sonst ist es $0$.
          Diese Karte wird zur optimierten Zählung der Häuser in einem Bereich verwendet.
          Statt ein bool pro Element zu verwenden, wird ein uint8\_t benutzt, da so die Speicherplatzspezifische Optimierung eines std::vector<bool> umgangen wird, was die Laufzeit verbessert.
    \item Und ein std::vector aller besten Arrangements, die jeweils als \textbf{Arrangement} Instanzen repräsentiert sind.
          Diese enthalten jeweils die Positionen der Eisdielen und den Score des Arrangements.
\end{itemize}

\subsection{Scored Search}
\label{sec:Scored_Search}
Der erste Schritt ist die Berechnung der Arrangements mit den besten Scores.
Hierzu wird die Funktion \textbf{do\_scored\_search} verwendet.
In ihr werden in drei verschachtelten Schleifen alle Test-Arrangements durchgegangen.
Zu beachten ist, dass die erste Position angefangen von $0$ hochzählt, während die zweite Position eine Adresse nach der ersten Position anfängt.
Gleichen gilt für die dritte Position.
Hierdurch werden die in \autoref{sec:Bestimmung_der_Stabilität} aufgezählten Optimierungen umgesetzt, die genauso für Test-Arrangements gelten können als auch für Check-Arrangements.
Die Adressen der Eisdielen werden in einer neuen \textbf{Arrangement} Instanz gespeichert.

Für jedes Arrangement wird die Eisdielendistanz jedes Hauses mit \textbf{get\_ice\_cream\_distance} berechnet und zusammenaddiert.
In \autoref{sec:Sortierung_der_Arrangements} wird zwar die durchschnittliche Eisdielendistanz berechnet, wofür die Summe durch die Menge an Häusern geteilt werden müsste.
Allerdings werden im folgenden Code die Scores nur miteinander verglichen, weshalb die Berechnung des absoluten Wertes unnötig ist.
Sie wird für die Optimierung weggelassen.

\medskip
\begin{addmargin}[3em]{4em}
    \textbf{get\_ice\_cream\_distance} berechnet mithilfe von \textbf{get\_shortest\_distance} die Entfernung von Einem Haus zu allen Eisdielen des Arrangements und wählt die kürzeste aus.
\end{addmargin}

\medskip
\begin{addmargin}[3em]{4em}
    \textbf{get\_shortest\_distance} berechnet die direkte und Entfernung zwischen zwei Adressen und die indirekte, wobei die direkte Entfernung von dem Umfang des Sees abgezogen wird.
    Schlussendlich gibt es die kürzere Entfernung zurück.
\end{addmargin}

\medskip
Dieser Score wird in der \textbf{Arrangement} Instanzen gespeichert.
Um die Arrangements effizient zu sortieren, wird zuerst der std::vector in der \textbf{Lake} Instanz, der die besten Arrangements enthalten soll, mit so vielen Dummy Arrangements gefüllt, wie beste Arrangements gefordert sind.
Wenn eine weitere \textbf{Arrangement} Instanz erstellt wurde, wird diese mit der Funktion \textbf{insert} an der richtigen Stelle in den std::vector eingefügt.
Anschließend wird das letzte Element, das mit dem schlechtesten Score, entfernt.
Diese vorgehensweise hat den Vorteil, dass der std::vector zu jedem Zeitpunkt sortiert ist.

Der Score der Dummy Arrangements entspricht dem Produkt aus Umfang und Menge an Häusern.
Dieser Score ist schlechter als alle möglichen Scores, weshalb ein Dummy gegen jegliche Test-Arrangements ersetzt wird.

\subsection{Überprüfung der Stabilität}
\label{sec:Überprüfung_der_Stabilität}
Wenn die besten Test-Arrangements berechnet wurden, werden sie anschließend alle mit der Funktion \textbf{is\_stable} auf Stabilität überprüft.
Diese nimmt ein Test-Arrangement entgegen und geht alle möglichen Check-Arrangements durch, bis entweder ein Check-Arrangement gefunden wurde, dass gegen das Test-Arrangements in einer Abstimmung gewinnen und es ablösen würde, oder entdeckt wird, dass kein derartiges Check-Arrangement vorliegen kann.

\medskip
Hierzu wird anfänglich für jedes Haus die Eisdielendistanz in dem Test-Arrangement berechnet und in den jeweiligen \textbf{House} Instanzen gespeichert.
Genau wie in \autoref{sec:Scored_Search} werden die in \autoref{sec:Bestimmung_der_Stabilität} genannten Optimierungen implementiert.
Der einzige Unterschied ist dass, wenn die ersten beiden Positionen gewählt wurden, die Suche nach einer Dritten nicht begonnen wird, wenn wie in \autoref{sec:Auszählung_der_Stimmen} gezeigt bereits zu viele Stimmen gegen eine Verlegung in dem ersten Bereich gefunden werden.

\subsubsection{Nein-Stimmenzählung in einem Sektor}
\label{sec:Stimmenzählung_in_einem_Sektor}
Um die Menge an Nein-Stimmen im Sektor zwischen den ersten beiden Eisdielen zu berechnen, wird die Funktion \textbf{count\_sector\_nos} eingesetzt.
Diese berechnet zuerst die nächste Test-Eisdiele innerhalb des Sektors von der linken Seite.
Dafür wird \textbf{get\_abs\_distance} eingesetzt und mit der geringstern Entfernung weitergerechnet.

\medskip
\begin{addmargin}[3em]{4em}
    \textbf{get\_abs\_distance} wird durch eine Instanze der Enum Class \textbf{Direction} auf Links- oder Rechtssuche eingestellt.
    Dementsprechend wird zurerst die direkte Distanz zwischen dem Startpunkt und dem Endpunkt berechnet.
    Wenn die direkte Distanz negativ ist, wird stattdessen die indirekte zurückgegeben.
    Hierdurch wird immer ein nicht-negativer Wert zurückgegeben.
\end{addmargin}

\medskip
Um zu detektieren, dass sich keine Test-Eisdiele in dem Sektor befindet, wird überprüft, ob die Breite des Sektors geringer als die Distanz zur nächsten Test-Eisdiele ist.
Wenn dies der Fall ist, ist selbst die nächste Test-Eisdiele nicht im Sektor enthalten und Alle Häuser in dem Sektor stimmen für eine Verlegung, weshalb sofort $0$ zurückgegeben wird.

Ist dies nicht der Fall, wird nach einer zweiten Test-Eisdiele in dem Sektor gesucht.
Hierfür wird das selbe Verfahren angewendet, mit dem Unterschied, dass statt in die rechte Richtung, die Entfernung in die linke Richtung und statt der linken Grenze des Sektors, die rechte verwendet wird.
So werden die beiden äußeren Test-Eisdielen berechnet, die die selbe sein können, wenn nur eine Test-Eisdiele im Sektor vorhanden ist.

\medskip
Nun werden die in \autoref{sec:Auszählung_der_Stimmen} vorgestellten Mitten berechnet und die Häuser in den beschriebenen Nein-stimmenden Bereichen gezählt.

\medskip
\begin{addmargin}[3em]{4em}
    Diese Aufgabe übernimmt die Funktion \textbf{count\_houses}, die die in der \textbf{Lake} Instanz gespeicherte Karte verwendet.
    Sie geht alle Adressen von dem Startwert bis zu der Adresse vor dem Endwert durch und addiert die in der Karte enthaltenen Elemente.
    In einer Schleife wird hierdurch von einer Entfernung zum Anfangswert von $0$ bis zu der Distanz zu dem Endwerte die Karte durchgegangen.
    Um ausgehend von der Entfernung zum Anfangswert die Adresse zu berechnen wird die Entfernung auf die Adresse des Anfangswertes addiert und der Rest der Division durch den Umfang des Sees verwendet.
\end{addmargin}

\medskip
So ergibt sich die Menge an Häusern in den festgelegten Bereichen, die zusammenaddiert zurückgegen werden.

\subsubsection{Simulation der Abstimmung}
Wenn im ersten Sektor nicht zu viele Nein-Stimmen enthalten sind, kann die selbe Funktion benutzt werden, um ebenfalls die Menge an Nein-Stimmen in den anderen beiden Sektoren zu berechnen.
Allerdings stellt sich heraus, dass die Simulation der Abstimmung eine bessere Laufzeit aufweist.
Hierfür wird die Funktion \textbf{is\_better} verwendet.
Sie geht alle Häuser durch und vergleicht die Eisdielendistanz mit dem Check-Arrangement eines Hauses mit dessen gespeicherte Eisdielendistanz.
Diese wurde am Anfang von \textbf{is\_stable} für das Test-Arrangement berechnet, damit sie nicht für jedes Check-Arrangement neu berechnet werden muss.
Hierdurch wird die Stimme des Hauses bestimmt.
Die Ja-Stimmen werden zusammenaddiert und mit der Menge an Nein-Stimmen, die der Differenz zwischen Anzahl an Häusern und Ja-Stimmen entspricht, verglichen.

\medskip
Sind mehr Ja- als Nein-Stimmen vorhanden, wird die Suche nach einem Check-Arrangement abgebrochen und false ausgegeben, da die Instabilität bewiesen wurde.
Nur in dem Fall, in dem die Suche alle möglichen Check-Arrangements durchlaufen hat und nicht abgebrochen wurde, ist das Test-Arrangement stabil.
Alle stabilen Ergebnisse werden in der Konsole ausgegeben.

\section{Zugeständnisse}
Das Programm besteht aus zwei Teilen.
Der eine, die Funktion \textbf{is\_stable}, produziert bewiesenermaßen stabile Arrangements, ist allerdings zu langsam, um auf alle möglichen Arrangements angewendet zu werden.
Auf der anderen Seite steht die Suche nach den besten Arrangements durch die durchschnittliche Eisdielendistanz, \textbf{do\_scored\_search}.
Diese lässt sich nur empirisch beweisen und ist damit kein Garant für eine perfekte Lösung.
Dafür ist sie äußerst schnell, weshalb es kein Problem ist, hiermit alle möglichen Arrangements durchzugehen.

Die Kombination dieser beiden Teile führt dazu, dass wenn das Programm ein stabiles Arrangement ausgibt, dieses definitiv stabil ist.
Wenn das Programm allerdings kein stabiles Arrangement findet, besteht immer noch die Möglichkeit, dass es doch ein stabiles Arrangements gibt, dass nur eine hohe durchschnittliche Eisdielendistanz aufweist und daher noch nicht auf Stabilität geprüft wurde.
Deshalb sollte die Menge an Arrangements, die überprüft werden soll, möglichst groß gewählt werden, um die Wahrscheinlichkeit, dass ein stabiles Arrangement nicht gefunden wird, minimiert wird.
Dadurch ist dieses Programm nicht als perfekte Lösung des Problems zu betrachten.

Zudem ist an dem Programm auszusetzten, dass die Laufzeit stark von der Eingabedatei abhängt, während für \textit{eisbuden1.txt} bereits nach etwa $200\mu s$ das erste stabile Ergebnis gefunden wird, benötigt es für \textit{eisbuden7} $11s$.
Die Laufzeit ist erheblich größer, wenn alle stabilen Arrangements gefordert sind ($1,5ms$ beziehungsweise $115s$).

\section{Beispiele}
% Genügend Beispiele einbinden! Die Beispiele von der BwInf-Webseite sollten hier diskutiert werden, aber auch eigene Beispiele sind sehr gut – besonders wenn sie Spezialfälle abdecken. Aber bitte nicht 30 Seiten Programmausgabe hier einfügen!
Nun wird das Programm mit allen Beispieldateien ausgeführt.

\begin{figure}[ht]
    \centering
    \setcounter{figure}{8}
    \caption{Beispiele vom BWINF}
    \label{fig:BWINF_Beispiele}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{eisbuden1.png}
        \caption{eisbuden1.txt}
        \label{fig:eisbuden1}
    \end{subfigure}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{eisbuden2.png}
        \caption{eisbuden2.txt}
        \label{fig:eisbuden2}
    \end{subfigure}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{eisbuden3.png}
        \caption{eisbuden3.txt}
        \label{fig:eisbuden3}
    \end{subfigure}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{eisbuden4.png}
        \caption{eisbuden4.txt}
        \label{fig:eisbuden4}
    \end{subfigure}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{eisbuden5.png}
        \caption{eisbuden5.txt}
        \label{fig:eisbuden5}
    \end{subfigure}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{eisbuden6.png}
        \caption{eisbuden6.txt}
        \label{fig:eisbuden6}
    \end{subfigure}
    \begin{subfigure}[t]{\imageWidth}
        \includegraphics[width=\linewidth]{eisbuden7.png}
        \caption{eisbuden7.txt}
        \label{fig:eisbuden7}
    \end{subfigure}
\end{figure}

\subsection{Eigene Beispiele}

\section{Quellcode}
% Unwichtige Teile des Programms sollen hier nicht abgedruckt werden. Dieser Teil sollte nicht mehr als 2–3 Seiten umfassen, maximal 10.
Dies sind die wichtigsten Funktionen:
\begin{lstlisting}
\end{lstlisting}

\end{document}
