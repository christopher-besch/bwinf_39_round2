#include <iostream>
#include <fstream>
#include <vector>
#include <array>
#include <math.h>

#ifdef DEBUG
#define raise_error(msg)                                                                                                  \
    {                                                                                                                     \
        std::cerr << msg << " (in: " << __FILE__ << ":" << __LINE__ << "; in function: " << __func__ << ")" << std::endl; \
        std::exit(EXIT_FAILURE);                                                                                          \
    }
#else
#define raise_error(msg)               \
    {                                  \
        std::cerr << msg << std::endl; \
        std::exit(EXIT_FAILURE);       \
    }
#endif

void checked_getline(std::istream &in_stream, std::string &out_str, char delimiter = '\n')
{
    if (!std::getline(in_stream, out_str, delimiter) || out_str.empty())
        raise_error("File Parsing Error: More lines required!");
}

int checked_stoi(std::string str)
{
    try
    {
        return std::stoi(str);
    }
    catch (std::invalid_argument ex)
    {
        raise_error("File Parsing Error: Can't convert \"" << str << "\" to int!");
    }
}

enum class Direction
{
    left,
    right
};

struct Lake
{
    int circumference;
    std::vector<int> houses;
    // one more yes-votes and the test position is unstable regarding some dummy position
    int max_yes;
    // not using bool to prevent space-efficient specialization
    // allows multiple houses in same location
    std::vector<uint8_t> houses_map;

    // debug
    void print_houses() const
    {
        for (auto place : houses_map)
        {
            if (place)
                std::cout << '|';
            else
                std::cout << '_';
        }
        std::cout << std::endl;
    }
    void print_places(int test_place, int place_a, int place_b, int place_c = -1) const
    {
        for (int idx = 0; idx < circumference; ++idx)
        {
            if (idx == test_place)
                std::cout << '^';
            else if (idx == place_a)
                std::cout << 'a';
            else if (idx == place_b)
                std::cout << 'b';
            else if (idx == place_c)
                std::cout << 'c';
            else
                std::cout << ' ';
        }
        std::cout << std::endl;
    }
    void print_middles(int middle_left, int middle_right) const
    {
        for (int idx = 0; idx < circumference; ++idx)
        {
            if (idx == middle_left)
                std::cout << '|';
            else if (idx == middle_right)
                std::cout << '|';
            else
                std::cout << ' ';
        }
        std::cout << std::endl;
    }
};

Lake read_file(const char *file_path)
{
    std::fstream file;
    file.open(file_path);
    if (!file)
        raise_error("Can't open input file!");

    std::string input_buffer;
    checked_getline(file, input_buffer, ' ');
    Lake lake;
    lake.circumference = checked_stoi(input_buffer);

    checked_getline(file, input_buffer, '\n');
    int amount_houses = checked_stoi(input_buffer);
    lake.max_yes = amount_houses / 2;

    lake.houses.resize(amount_houses);
    lake.houses_map.resize(lake.circumference);
    for (int idx = 0; idx < amount_houses; idx++)
    {
        checked_getline(file, input_buffer, ' ');
        int house_location = checked_stoi(input_buffer);
        lake.houses[idx] = house_location;
        ++lake.houses_map[house_location];
    }
    return lake;
}

// use specified direction; automatically detects if indirect way is required
int get_abs_distance(int circumference, int this_place, int other_place, Direction direction)
{
    int direct_distance = direction == Direction::left ? this_place - other_place : other_place - this_place;
    // only correct when direct_distance is negative
    int indirect_distance = circumference + direct_distance;
    return direct_distance < 0 ? indirect_distance : direct_distance;
}

// test_place is between place_a and place_b
// count amount of people voting for changing to test_place
int count_yes(Lake lake, int test_place, int place_a, int place_b)
{
    // get outer area of yes-voting houses
    int distance_a_left = get_abs_distance(lake.circumference, test_place, place_a, Direction::left);
    int distance_b_left = get_abs_distance(lake.circumference, test_place, place_b, Direction::left);
    int distance_a_right = get_abs_distance(lake.circumference, test_place, place_a, Direction::right);
    int distance_b_right = get_abs_distance(lake.circumference, test_place, place_b, Direction::right);

    int distance_left = distance_a_left < distance_b_left ? distance_a_left : distance_b_left;
    int distance_right = distance_a_left < distance_b_left ? distance_b_right : distance_a_right;
    int middle_left = (test_place - (distance_left - 1) / 2) % lake.circumference;
    // always get bigger number with odd numbers: 9 + 1 // 2 = 5
    int middle_right = (test_place + (distance_right + 1) / 2) % lake.circumference;

    // debug
    // lake.print_houses();
    // lake.print_places(test_place, place_a, place_b);
    // lake.print_middles(middle_left, middle_right);

    // count all houses from middle_left to one before middle_right
    int yes = 0;
    for (int current_location = middle_left; current_location != middle_right;)
    {
        yes += lake.houses_map[current_location];
        ++current_location;
        // rollover
        if (current_location == lake.circumference)
            current_location = 0;
    }
    // debug
    // std::cout << yes << std::endl;
    // std::cout << std::endl;
    return yes;
}

bool does_allow_destabilizing(Lake lake, int place_a, int place_b)
{
    // std::cout << "--------------------" << std::endl;
    // test all locations between place_a and place_b
    for (int idx = 1; idx < get_abs_distance(lake.circumference, place_a, place_b, Direction::right); idx++)
    {
        int test_place = (place_a + idx) % lake.circumference;
        // how many people would vote for test_place with the ice cream parlors place_a, place_b and one between these two on the other side of the lake
        // if (count_yes(lake, test_place, place_a, place_b) > lake.max_yes)
        int yes = count_yes(lake, test_place, place_a, place_b);
        if (yes > (lake.houses.size() - yes))
            return true;
    }
    return false;
}

int main(int argc, char *argv[])
{
    if (argc < 2)
        raise_error("Please specify the input file as the first console parameter.");

    Lake lake = read_file(argv[1]);

    // three ints each
    std::vector<int> result_sets;

    // go through all possible locations for first ice
    for (int place_a = 0; place_a < lake.circumference; ++place_a)
    {
        std::cout << place_a << std::endl;
        // go through all possible locations for second ice
        // todo: bad + 1
        for (int place_b = place_a + 1; place_b < lake.circumference; ++place_b)
        {
            // test if there is a location between these two that would make any other location unstable
            if (does_allow_destabilizing(lake, place_a, place_b))
                // if the gap gets bigger, only more possible destabilizing location will be found
                break;
            // test all possible locations for third ice
            // todo: bad + 1
            for (int place_c = place_b + 1; place_c < lake.circumference; ++place_c)
            {
                // when the second gap gets too big
                if (does_allow_destabilizing(lake, place_b, place_c))
                    break;
                // when the third gap is still too big
                if (!does_allow_destabilizing(lake, place_c, place_a))
                {
                    // debug
                    // lake.print_houses();
                    // lake.print_places(-1, place_a, place_b, place_c);
                    // std::cout << std::endl;
                    result_sets.push_back(place_a);
                    result_sets.push_back(place_b);
                    result_sets.push_back(place_c);
                }
            }
        }
    }
    std::cout << result_sets.size() / 3 << std::endl;
    return 0;
}
