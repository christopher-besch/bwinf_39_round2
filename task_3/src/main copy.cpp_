#include <iostream>
#include <fstream>
#include <vector>
#include <array>
#include <math.h>

#ifdef DEBUG
#define raise_error(msg)                                                                                                  \
    {                                                                                                                     \
        std::cerr << msg << " (in: " << __FILE__ << ":" << __LINE__ << "; in function: " << __func__ << ")" << std::endl; \
        std::exit(EXIT_FAILURE);                                                                                          \
    }
#else
#define raise_error(msg)               \
    {                                  \
        std::cerr << msg << std::endl; \
        std::exit(EXIT_FAILURE);       \
    }
#endif

void checked_getline(std::istream &in_stream, std::string &out_str, char delimiter = '\n')
{
    if (!std::getline(in_stream, out_str, delimiter) || out_str.empty())
        raise_error("File Parsing Error: More lines required!");
}

int checked_stoi(std::string str)
{
    try
    {
        return std::stoi(str);
    }
    catch (std::invalid_argument ex)
    {
        raise_error("File Parsing Error: Can't convert \"" << str << "\" to int!");
    }
}

enum class Direction
{
    left,
    right
};

struct Lake
{
    int circumference;
    std::vector<int> houses;
    // one more yes-votes and the test position is unstable regarding some dummy position
    int max_yes;
    // not using bool to prevent space-efficient specialization
    // allows multiple houses in same location
    std::vector<uint8_t> houses_map;
};

Lake read_file(const char *file_path)
{
    std::fstream file;
    file.open(file_path);
    if (!file)
        raise_error("Can't open input file!");

    std::string input_buffer;
    checked_getline(file, input_buffer, ' ');
    Lake lake;
    lake.circumference = checked_stoi(input_buffer);

    checked_getline(file, input_buffer, '\n');
    int amount_houses = checked_stoi(input_buffer);
    lake.max_yes = amount_houses / 2;

    lake.houses.resize(amount_houses);
    lake.houses_map.resize(lake.circumference);
    for (int idx = 0; idx < amount_houses; idx++)
    {
        checked_getline(file, input_buffer, ' ');
        int house_location = checked_stoi(input_buffer);
        lake.houses[idx] = house_location;
        ++lake.houses_map[house_location];
    }
    return lake;
}

// use specified direction; automatically detects if indirect way is required
int get_abs_distance(int circumference, int this_place, int other_place, Direction direction)
{
    int direct_distance = direction == Direction::left ? this_place - other_place : other_place - this_place;
    // only correct when direct_distance is negative
    int indirect_distance = circumference + direct_distance;
    return direct_distance < 0 ? indirect_distance : direct_distance;
}

// get middle index between a and b; always prefer position closer to test_place when there are two possible middles
int get_middle(int test_place, int other)
{
    int distance = other - test_place;
    // add 1 to all odd negative distances, e.g. -5
    distance += distance % 2 && distance < 0;
    return test_place + distance / 2;
}

void print_houses(Lake lake)
{
    for (auto place : lake.houses_map)
    {
        if (place)
            std::cout << '|';
        else
            std::cout << '_';
    }
    std::cout << std::endl;
}
void print_places(Lake lake, int test_place, int place_a, int place_b)
{
    for (int idx = 0; idx < lake.circumference; ++idx)
    {
        if (idx == test_place)
            std::cout << '^';
        else if (idx == place_a)
            std::cout << 'a';
        else if (idx == place_b)
            std::cout << 'b';
        else
            std::cout << ' ';
    }
    std::cout << std::endl;
}
void print_middles(Lake lake, int middle_left, int middle_right)
{
    for (int idx = 0; idx < lake.circumference; ++idx)
    {
        if (idx == middle_left)
            std::cout << '|';
        else if (idx == middle_right)
            std::cout << '|';
        else
            std::cout << ' ';
    }
    std::cout << std::endl;
}

bool test_place(Lake lake, int test_place, int place_a, int place_b)
{
    // get outer area of yes-voting houses
    int distance_a_left = get_abs_distance(lake.circumference, test_place, place_a, Direction::left);
    int distance_b_left = get_abs_distance(lake.circumference, test_place, place_b, Direction::left);
    int distance_a_right = get_abs_distance(lake.circumference, test_place, place_a, Direction::right);
    int distance_b_right = get_abs_distance(lake.circumference, test_place, place_b, Direction::right);

    int distance_left = distance_a_left < distance_b_left ? distance_a_left : distance_b_left;
    int distance_right = distance_a_left < distance_b_left ? distance_b_right : distance_a_right;
    int middle_left = test_place - distance_left / 2;
    int middle_right = test_place + distance_right / 2;

    // count all houses between these middles
    int yes = 0;
    for (int current_location = middle_left; current_location != middle_right;)
    {
        yes += lake.houses_map[current_location];
        ++current_location;
        // rollover
        if (current_location == lake.circumference)
            current_location = 0;
    }
    print_houses(lake);
    print_places(lake, test_place, place_a, place_b);
    print_middles(lake, middle_left, middle_right);
    return !(yes > lake.max_yes);
}

int main_(int argc, char *argv[])
{
    Lake lake = read_file(argv[1]);
    test_place(lake, 10, 5, 15);
    return 0;
}

int main__(int argc, char *argv[])
{
    if (argc < 2)
        raise_error("Please specify the input file as the first console parameter.");

    Lake lake = read_file(argv[1]);

    // three ints each
    std::vector<int> result_sets;

    // go through all possible locations for first ice
    for (int ice_a = 0; ice_a < lake.circumference; ++ice_a)
    {
        std::cout << ice_a << std::endl;
        // go through all possible locations for second ice
        for (int ice_b = ice_a + 1; ice_b < lake.circumference; ++ice_b)
        {
            // test all possible locations for third ice
            for (int ice_c = ice_b + 1; ice_c < lake.circumference; ++ice_c)
            {
                // test all three locations for stability
                // each test expects the other locations to be stable
                bool a = test_place(lake, ice_a, ice_b, ice_c);
                bool b = test_place(lake, ice_b, ice_c, ice_a);
                bool c = test_place(lake, ice_c, ice_a, ice_b);

                if (test_place(lake, ice_a, ice_b, ice_c) &&
                    test_place(lake, ice_b, ice_c, ice_a) &&
                    test_place(lake, ice_c, ice_a, ice_b))
                {
                    result_sets.push_back(ice_a);
                    result_sets.push_back(ice_b);
                    result_sets.push_back(ice_c);
                }
            }
        }
    }

    std::cout << "Hello" << std::endl;

    return 0;
}

int main(int argc, char *argv[])
{
    if (argc < 2)
        raise_error("Please specify the input file as the first console parameter.");

    Lake lake = read_file(argv[1]);

    // three ints each
    std::vector<int> result_sets;

    // go through all possible locations for first ice
    for (int place_a = 0; place_a < lake.circumference; ++place_a)
    {
        // go through all possible locations for second ice
        for (int place_b = place_a; place_b < lake.circumference; ++place_b)
        {
            // test if there is a location between these two that would make any other location unstable
            if (does_allow_destabilizing(lake, place_a, place_b))
                // if the gap gets bigger, only more possible destabilizing location will be found
                break;
            // test all possible locations for third ice
            for (int place_c = place_b; place_c < lake.circumference; ++place_c)
            {
                // when the second gap gets too big
                if (does_allow_destabilizing(lake, place_b, place_c))
                    break;
                // when the third gap is still too big
                if (!does_allow_destabilizing(lake, place_c, place_a))
                {
                    result_sets.push_back(place_a);
                    result_sets.push_back(place_b);
                    result_sets.push_back(place_c);
                }
            }
        }
    }
    return 0;
}
